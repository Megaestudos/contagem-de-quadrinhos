<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Contagem de Motoristas — Diagnóstico Robusto</title>
<style>
  body{font-family:Arial,Helvetica,sans-serif;background:linear-gradient(#eaf6ff,#d9efff);margin:0;color:#123;}
  .wrap{max-width:1100px;margin:18px auto;padding:18px}
  .status{padding:14px;border-radius:12px;background:#fff;border:1px solid #e2f0ff;margin-bottom:12px}
  .status.error{background:#fff1f0;border-color:#f5c6c6;color:#8b1a1a}
  .card{background:#fff;padding:14px;border-radius:12px;box-shadow:0 6px 18px rgba(11,36,64,0.06);margin-bottom:14px}
  h1{margin:0 0 8px 0;text-align:center;color:#0b67a3}
  table{width:100%;border-collapse:collapse}
  th,td{padding:10px;border-bottom:1px solid #eef7ff;text-align:left}
  th{background:#f1fbff;color:#0b3950;font-weight:700}
  .muted{color:#6b8796;font-size:13px}
  .mini{font-size:13px;color:#445}
  pre{white-space:pre-wrap;word-break:break-word;background:#f7fbff;padding:10px;border-radius:8px;border:1px solid #e6f4ff}
  .btn{display:inline-block;padding:8px 12px;border-radius:8px;background:#0b67a3;color:white;border:none;cursor:pointer}
</style>
</head>
<body>
  <div class="wrap">
    <h1>Contagem de Motoristas — Loader Diagnóstico</h1>

    <div id="uiStatus" class="status">Inicializando...</div>

    <div class="card">
      <div style="display:flex;gap:8px;flex-wrap:wrap;align-items:center">
        <div class="mini"><strong>Sheet ID</strong> (edite aqui se precisar):</div>
        <input id="sheetIdInput" style="flex:1;padding:8px;border-radius:8px;border:1px solid #d6eaf8" value="1eaFPPSEpMxsdUY9m3vT_fOhoYUKYBzATv55nRHQwyTY">
        <button id="btnReload" class="btn">Recarregar</button>
      </div>
      <div style="margin-top:8px" class="muted">
        OBS: Planilha deve estar pública (Qualquer pessoa com o link — Leitor). Se preferir, use "Publicar na web".
      </div>
    </div>

    <div id="detail" class="card">
      <div class="mini"><strong>Resultado das tentativas</strong></div>
      <div id="attempts" style="margin-top:8px"></div>
    </div>

    <div class="card">
      <div class="mini"><strong>Top 7 — Chegadas Cedo (ANTES DO EXPEDIENTE)</strong></div>
      <div id="rankingAntes" style="margin-top:8px">—</div>
    </div>

    <div class="card">
      <div class="mini"><strong>Top 7 — Saídas Tarde (DEPOIS DO EXPEDIENTE)</strong></div>
      <div id="rankingDepois" style="margin-top:8px">—</div>
    </div>

    <div class="card">
      <div class="mini"><strong>Registros — Antes do expediente</strong></div>
      <div id="tableBeforeWrap" style="margin-top:8px"><div class="muted">vazio</div></div>
    </div>

    <div class="card">
      <div class="mini"><strong>Registros — Depois do expediente</strong></div>
      <div id="tableAfterWrap" style="margin-top:8px"><div class="muted">vazio</div></div>
    </div>

    <div class="card">
      <div class="mini"><strong>Resposta bruta (trecho)</strong> — útil para debug</div>
      <pre id="rawPreview">—</pre>
    </div>
  </div>

<script>
/* ---------------- CONFIG (pode editar) ---------------- */
let SHEET_ID = document.getElementById('sheetIdInput').value.trim();
const ABA_ANTES = "ANTES DO EXPEDIENTE";
const ABA_DEPOIS = "DEPOIS DO EXPEDIENTE";

/* ---------------- UI helpers ---------------- */
const uiStatus = id('uiStatus');
const attemptsEl = id('attempts');
const rawPreview = id('rawPreview');
const rankingAntes = id('rankingAntes');
const rankingDepois = id('rankingDepois');
const tableBeforeWrap = id('tableBeforeWrap');
const tableAfterWrap = id('tableAfterWrap');

document.getElementById('btnReload').addEventListener('click', ()=>{
  SHEET_ID = id('sheetIdInput').value.trim();
  runAll();
});

/* ---------------- util parse functions ---------------- */
function tryParseGviz(text){
  // find first { ... } block
  const start = text.indexOf('{');
  const end = text.lastIndexOf('}');
  if (start === -1 || end === -1) return null;
  try {
    return JSON.parse(text.slice(start, end+1));
  } catch(e){
    return null;
  }
}

// robust parse for cells (Date(...) , serial numbers, dd/mm/yyyy, ISO)
function parseCellValue(v){
  if (v === null || v === undefined) return {date:null, text:""};
  const s = String(v).trim();

  // Date(...) pattern
  const m = s.match(/^Date\(([-\d,\s]+)\)$/i);
  if (m){
    const parts = m[1].split(',').map(x=>parseInt(x.trim(),10));
    if (parts.length >= 3){
      let [year, monthZero, day, hour=0, minute=0, second=0] = parts;
      if (!isNaN(year) && !isNaN(monthZero) && !isNaN(day)){
        // if year < 1900 treat as time-only
        if (year < 1900){
          const now = new Date();
          return { date: new Date(now.getFullYear(), now.getMonth(), now.getDate(), hour, minute, second), text:"" };
        }
        return { date: new Date(year, monthZero, day, hour, minute, second), text:"" };
      }
    }
  }

  // numeric serial (Excel/Sheets) or timestamp
  if (/^-?\d+(\.\d+)?$/.test(s)){
    // if it's float -> maybe sheet serial with fractional day (time)
    const num = Number(s);
    // Heuristic: sheet serials (days since 1899-12-30) usually < 50000 for current dates
    if (Math.abs(num) < 60000){
      // serial (days)
      const base = new Date(1899,11,30);
      const ms = Math.round(num * 86400000);
      const d = new Date(base.getTime() + ms);
      return { date: d, text: "" };
    } else {
      // timestamp: convert seconds->ms if small
      const ms = Math.abs(num) < 1e12 ? num * 1000 : num;
      const d = new Date(ms);
      if (!isNaN(d)) return { date: d, text: "" };
    }
  }

  // dd/mm/yyyy or dd-mm-yyyy (pt-BR)
  let dm = s.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2,4})$/);
  if (dm){
    let day = parseInt(dm[1],10), month = parseInt(dm[2],10), year = parseInt(dm[3],10);
    if (year < 100) year += 2000;
    const d = new Date(year, month-1, day);
    if (!isNaN(d)) return {date:d, text:""};
  }

  // ISO parse
  const iso = Date.parse(s);
  if (!isNaN(iso)) return { date: new Date(iso), text: "" };

  // fallback
  return { date: null, text: s };
}

function formatDate(d){
  if (!d) return "";
  return d.toLocaleDateString('pt-BR');
}
function formatTime(d){
  if (!d) return "";
}

/* ---------------- CSV fallback parser ---------------- */
function parseCSV(text){
  // simple RFC4180-like parser that supports quoted fields
  const rows = [];
  let cur = '';
  let row = [];
  let inQuotes = false;
  for (let i=0;i<text.length;i++){
    const ch = text[i];
    const nxt = text[i+1];
    if (ch === '"'){
      if (inQuotes && nxt === '"'){ cur += '"'; i++; continue; }
      inQuotes = !inQuotes;
      continue;
    }
    if (!inQuotes && ch === ','){ row.push(cur); cur=''; continue; }
    if (!inQuotes && (ch === '\r' || ch === '\n')){
      if (ch === '\r' && text[i+1] === '\n'){ i++; } // windows
      row.push(cur); cur=''; rows.push(row); row=[];
      continue;
    }
    cur += ch;
  }
  // last
  if (cur !== '' || row.length) row.push(cur);
  if (row.length) rows.push(row);
  return rows.filter(r => r.some(c => c !== undefined && String(c).trim() !== ''));
}

/* ---------------- fetch helpers ---------------- */
async function fetchGviz(sheetName){
  const url = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/gviz/tq?tqx=out:json&sheet=${encodeURIComponent(sheetName)}`;
  const res = await fetch(url, {cache:'no-store'});
  const text = await res.text();
  return { status: res.status, text };
}

async function fetchCSV(sheetName){
  const url = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/gviz/tq?tqx=out:csv&sheet=${encodeURIComponent(sheetName)}`;
  const res = await fetch(url, {cache:'no-store'});
  const text = await res.text();
  return { status: res.status, text };
}

/* ---------------- process GViz JSON result into rows array ---------------- */
function rowsFromGvizObj(obj){
  const rows = (obj.table && obj.table.rows) ? obj.table.rows : [];
  return rows.map(r => (r.c || []).map(c => {
    if (!c) return null;
    // prefer formatted
    if (c.f && typeof c.f === 'string') return c.f;
    if (c.v !== undefined && c.v !== null) return String(c.v);
    return null;
  }));
}

/* ---------------- main logic: try multiple strategies ---------------- */
async function runAll(){
  clearUI();
  setStatus('Iniciando leitura — tentando GViz JSON primeiro...');

  attemptsEl.innerHTML = '';
  rawPreview.textContent = '—';

  try {
    // 1) Try GViz JSON for each sheet
    const tryGviz = await Promise.allSettled([
      fetchGviz(ABA_ANTES),
      fetchGviz(ABA_DEPOIS)
    ]);

    let okGviz = false;
    const results = [];

    for (let i=0;i<tryGviz.length;i++){
      const sname = i===0 ? ABA_ANTES : ABA_DEPOIS;
      const r = tryGviz[i];
      if (r.status === 'fulfilled'){
        results.push({sheet:sname, ok:true, status:r.value.status, text:r.value.text});
        // quick parse check
        const parsed = tryParseGviz(r.value.text);
        if (parsed && parsed.table && parsed.table.rows && parsed.table.rows.length>=0){
          okGviz = okGviz || true;
        }
      } else {
        results.push({sheet:sname, ok:false, error:r.reason});
      }
    }

    // show attempts
    attemptsEl.appendChild(renderAttempt('GViz JSON', results));

    // if GViz returned usable JSON, use it
    if (okGviz){
      setStatus('GViz JSON ok — processando dados...');
      // process both
      const a = tryGviz[0].value.text;
      const b = tryGviz[1].value.text;
      rawPreview.textContent = a.slice(0,1100) + (a.length>1100?'\n\n... (truncated)':'');
      const objA = tryParseGviz(a);
      const objB = tryParseGviz(b);
      const rowsA = rowsFromGvizObj(objA);
      const rowsB = rowsFromGvizObj(objB);
      return finalize(rowsA, rowsB, 'GViz JSON');
    }

    // 2) GViz JSON failed or unusable — try CSV fallback
    setStatus('GViz JSON não funcionou, tentando CSV fallback...');
    const tryCsv = await Promise.allSettled([ fetchCSV(ABA_ANTES), fetchCSV(ABA_DEPOIS) ]);
    const csvResults = [];
    let okCsv = false;
    for (let i=0;i<tryCsv.length;i++){
      const sname = i===0 ? ABA_ANTES : ABA_DEPOIS;
      const r = tryCsv[i];
      if (r.status === 'fulfilled'){
        csvResults.push({sheet:sname, ok:true, status:r.value.status, textPreview: r.value.text.slice(0,300)});
        if (r.value.text && r.value.text.length>0) okCsv = true;
      } else {
        csvResults.push({sheet:sname, ok:false, err:r.reason});
      }
    }
    attemptsEl.appendChild(renderAttempt('CSV fallback', csvResults));
    if (okCsv){
      setStatus('CSV retornado — processando CSV...');
      rawPreview.textContent = tryCsv[0].value.text.slice(0,1600) + (tryCsv[0].value.text.length>1600?'\n\n... (truncated)':'');
      const rowsA = parseCSV(tryCsv[0].value.text);
      const rowsB = parseCSV(tryCsv[1].value.text);
      // rows are arrays of strings (first row may be header) -> remove header if header appears
      return finalize(rowsA.slice(1), rowsB.slice(1), 'CSV fallback (gviz out:csv)');
    }

    // 3) All failed
    setStatus('Todas as tentativas falharam — ver detalhes abaixo', true);
    rawPreview.textContent = 'GViz attempts:\n' + JSON.stringify(results, null, 2) + '\n\nCSV attempts:\n' + JSON.stringify(csvResults, null, 2);
    return;
  } catch (err){
    setStatus('Erro inesperado: ' + (err && err.message), true);
    console.error(err);
    rawPreview.textContent = String(err);
  }
}

/* ---------------- finalize: normalize rows and render ---------------- */
function finalize(rowsA, rowsB, sourceLabel){
  // rowsA and rowsB are arrays of arrays (cells)
  attemptsEl.appendChild(renderAttempt('Resultado usado', [{sheet:ABA_ANTES, ok:true, source:sourceLabel}, {sheet:ABA_DEPOIS, ok:true, source:sourceLabel}]));

  // normalize: take first 4 columns (motorista,data,horario,missao)
  const normA = rowsA.map(r => normalizeRowArray(r));
  const normB = rowsB.map(r => normalizeRowArray(r));

  // filter empty
  const filteredA = normA.filter(r=>r.motorista || r.displayDate || r.displayTime);
  const filteredB = normB.filter(r=>r.motorista || r.displayDate || r.displayTime);

  // sort descending (recent first) by dateObj
  const ordA = filteredA.slice().sort((a,b)=>compareDatesDesc(a.dateObj,b.dateObj));
  const ordB = filteredB.slice().sort((a,b)=>compareDatesDesc(a.dateObj,b.dateObj));

  renderRankingList('rankingAntes', ordA);
  renderRankingList('rankingDepois', ordB);

  renderTable('tableBeforeWrap', ordA);
  renderTable('tableAfterWrap', ordB);

  setStatus('Dados carregados com sucesso (fonte: ' + sourceLabel + ')');
  return;
}

/* normalize a single row array -> {motorista, displayDate, displayTime, missao, dateObj} */
function normalizeRowArray(r){
  const motoristaRaw = r[0] || '';
  const dataRaw = r[1] || '';
  const horaRaw = r[2] || '';
  const missaoRaw = r[3] || '';
  const motorista = String(motoristaRaw).trim();

  const pd = parseCellValue(dataRaw);
  const pt = parseCellValue(horaRaw);

  let dateObj = null;
  if (pd.date && pt.date){
    const d = pd.date, t = pt.date;
    dateObj = new Date(d.getFullYear(), d.getMonth(), d.getDate(), t.getHours(), t.getMinutes(), t.getSeconds());
  } else if (pd.date){
    dateObj = pd.date;
  } else if (pt.date){
    const now = new Date();
    const t = pt.date;
    dateObj = new Date(now.getFullYear(), now.getMonth(), now.getDate(), t.getHours(), t.getMinutes(), t.getSeconds());
  } else {
    const combined = String(dataRaw||'') + ' ' + String(horaRaw||'');
    const p = Date.parse(combined);
    if (!isNaN(p)) dateObj = new Date(p);
  }

  const displayDate = pd.date ? pd.date.toLocaleDateString('pt-BR') : (pd.text || String(dataRaw||''));
  const displayTime = pt.date ? pt.date.toLocaleTimeString('pt-BR',{hour:'2-digit', minute:'2-digit'}) : (pt.text || String(horaRaw||''));

  return { motorista, displayDate, displayTime, missao: String(missaoRaw||''), dateObj };
}

/* compare helper */
function compareDatesDesc(a,b){
  if (!a && !b) return 0;
  if (!a) return 1;
  if (!b) return -1;
  return b - a;
}

/* render ranking */
function renderRankingList(containerId, items){
  const counts = {};
  items.forEach(it => { const k = it.motorista || 'Sem nome'; counts[k] = (counts[k]||0)+1; });
  const ranked = Object.entries(counts).sort((a,b)=>b[1]-a[1]).slice(0,7);
  const el = id(containerId);
  if (!ranked.length){ el.innerHTML = '<div class="muted">Sem registros</div>'; return; }
  el.innerHTML = ranked.map((r,i)=>`${i+1}. <strong>${escapeHtml(r[0])}</strong> — ${r[1]} registro(s)`).join('<br>');
}

/* render table area */
function renderTable(containerId, items){
  const wrap = id(containerId);
  if (!items || items.length===0){
    wrap.innerHTML = '<div class="muted">Sem registros</div>'; return;
  }
  let html = '<table><thead><tr><th>Motorista</th><th>Data</th><th>Horário</th><th>Missão</th></tr></thead><tbody>';
  for (let it of items){
    html += `<tr><td>${escapeHtml(it.motorista)}</td><td>${escapeHtml(it.displayDate)}</td><td>${escapeHtml(it.displayTime)}</td><td>${escapeHtml(it.missao)}</td></tr>`;
  }
  html += '</tbody></table>';
  wrap.innerHTML = html;
}

/* render attempt summary */
function renderAttempt(title, arr){
  const div = document.createElement('div');
  div.innerHTML = `<div style="font-weight:700;margin-bottom:6px">${title}</div>` + arr.map(a=>{
    if (a.ok === false) return `<div style="margin-bottom:6px"><strong>${a.sheet}</strong>: falha — ${escapeHtml(String(a.error || a.err || JSON.stringify(a)))}</div>`;
    if (a.status) return `<div style="margin-bottom:6px"><strong>${a.sheet}</strong>: HTTP ${a.status} — preview: ${escapeHtml(String(a.textPreview || String(a.text).slice(0,80)))}</div>`;
    return `<div style="margin-bottom:6px"><strong>${a.sheet}</strong>: ${escapeHtml(String(a.source || 'OK'))}</div>`;
  }).join('');
  return div;
}

/* misc helpers */
function setStatus(msg, isError=false){
  uiStatus.textContent = msg;
  uiStatus.className = 'status' + (isError ? ' error' : '');
}
function id(s){ return document.getElementById(s); }
function escapeHtml(s){ if (s===null||s===undefined) return ''; return String(s).replace(/[&<>"']/g, m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }

/* initial run */
runAll();

</script>
</body>
</html>
